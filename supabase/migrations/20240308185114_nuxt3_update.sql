-- Add the "original title" column to the requests table
alter table "public"."requests" add column if not exists "original_title" text;

-- Alter the create_request_clients_vendors trigger to use the original title as the label, instead of the citation.
CREATE OR REPLACE FUNCTION "public"."create_request_clients_vendors"() RETURNS trigger
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO public.request_clients (request_id, label)
    VALUES (new.id, new.original_title)
    ON CONFLICT (request_id) DO NOTHING;
  INSERT INTO public.request_vendors (request_id, label)
    VALUES (new.id, new.original_title)
    ON CONFLICT (request_id) DO NOTHING;
  return new;
END;
$$;

drop trigger if exists create_client_vendor_on_request_create on public.requests;
create trigger create_client_vendor_on_request_create
  after insert on public.requests
  for each row execute procedure public.create_request_clients_vendors();


alter table "public"."attachments" add column if not exists "path" text;

-- Alter the sent_chat function to also update request_vendor/request_client with has_unread
CREATE OR REPLACE FUNCTION "public"."sent_chat"(request_id bigint, user_id uuid) RETURNS bigint
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
  created_id int8;
  request public.requests%rowtype;
BEGIN
    SELECT * FROM public.requests INTO request WHERE id = $1;

    if request.user_id = $2 then
        UPDATE public.request_vendors pv
        SET has_unread = true
        WHERE pv.request_id = $1;
    else
        UPDATE public.request_clients pc
        SET has_unread = TRUE
        WHERE pc.request_id = $1;
    end if;

    INSERT INTO public.request_events (request_id, user_id, status_id, description)
    SELECT $1, $2, request.status_id, '%u initiated a chat.'
    WHERE NOT EXISTS(
        SELECT 1
        FROM public.request_events
        WHERE request_events.request_id = $1
        AND request_events.user_id = $2
        AND request_events.status_id = request.status_id
        AND request_events.description = '%u initiated a chat.'
        AND request_events.created_at >= NOW() - INTERVAL '5 minutes'
    ) RETURNING id into created_id;
    RETURN created_id;
END;
$_$;


CREATE OR REPLACE FUNCTION public.convert_request(prospective_request_id integer, repository_id integer)
 RETURNS SETOF requests
 LANGUAGE plpgsql
AS $function$
DECLARE
    rp RECORD;
    inserted_id INT;
BEGIN
    -- Get the prospective_request based on the passed parameter
    SELECT *
    INTO rp
    FROM requests_prospective
    WHERE id = prospective_request_id;

    INSERT INTO requests (repository_id, original_title, citation, pages, status_id, user_id)
    VALUES (repository_id, rp.title, rp.description, 0, 1, rp.user_id)
    RETURNING id INTO inserted_id;

    -- Return the inserted record
    UPDATE requests_prospective
    SET converted = TRUE
    WHERE id = prospective_request_id;

    RETURN query
    SELECT * FROM requests WHERE id = inserted_id;
END
$function$
;




DROP POLICY IF EXISTS "Allow read for creator" ON "public"."requests_prospective";
create policy "Allow read for creator"
on "public"."requests_prospective"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));

DROP POLICY IF EXISTS "Allow update for creator" ON "public"."requests_prospective";
create policy "Allow update for creator"
on "public"."requests_prospective"
as permissive
for update
to authenticated
using ((auth.uid() = user_id));



/**
* Notifications Table & RLS
*/
CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" bigint NOT NULL,
    "user_id" uuid,
    "read" boolean DEFAULT false NOT NULL,
    "text" text NOT NULL,
    "type" text NOT NULL,
    "data" jsonb,
    "created_at" timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

ALTER TABLE "public"."notifications" OWNER TO "postgres";

ALTER TABLE "public"."notifications" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."notifications_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "user"(id);

ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow Admin Access" ON "public"."notifications";
create policy "Allow Admin Access"
on "public"."notifications"
as permissive
for all 
to authenticated
using ((auth.uid() IN ( SELECT "user".id
   FROM "user"
  WHERE ("user".admin = true))));

DROP POLICY IF EXISTS "Allow Read for User" ON "public"."notifications";
create policy "Allow Read for User"
on "public"."notifications"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));

DROP POLICY IF EXISTS "Allow Insert for User" ON "public"."notifications";
create policy "Allow Insert for User"
on "public"."notifications"
for insert with check ((auth.uid() = user_id));

DROP POLICY IF EXISTS "Allow Update for User" ON "public"."notifications";
create policy "Allow Update for User"
on "public"."notifications"
for update
to authenticated
using ((auth.uid() = user_id));

-- Create a function to run after a request is created, particularly to create a notification for the receiving user.
CREATE OR REPLACE FUNCTION public.notification_new_request() RETURNS trigger AS $$
DECLARE
  organization_user_id uuid;
  notification_json json;
BEGIN
  -- Fetch the user_id from the organization table based on the repository_id
  SELECT id into organization_user_id
  FROM public.user WHERE id = (
    SELECT owner_id FROM organizations WHERE id = (
      SELECT organization_id FROM repositories WHERE id = new.repository_id
    )
  );

  -- Build Data JSON
  notification_json = jsonb_build_object(
    'request', new
  );

  -- Create a notification for the organization user --
  INSERT INTO public.notifications (user_id, text, type, data) VALUES (organization_user_id, 'New Request Submitted', 'new_request', notification_json);

  return new;
END;
$$ LANGUAGE plpgsql security definer;

-- Create a trigger to run the notification_new_request function after a request is created.
drop trigger if exists create_notification_on_new_request on public.requests;
create trigger create_notification_on_new_request
  after insert on public.requests
  for each row execute procedure public.notification_new_request();


-- Create a function to run after a request comment is created (chat message), particularly to create a notification for the receiving user.
CREATE OR REPLACE FUNCTION public.notification_new_message() RETURNS trigger AS $$
DECLARE
  organization_user_id uuid;
  notification_json json;
  request public.requests%rowtype;
BEGIN

  -- Fetch the request that the message is associated with
  SELECT * INTO request FROM public.requests WHERE id = new.request_id;

  -- Fetch the user_id from the organization table based on the repository_id
  SELECT id into organization_user_id
  FROM public.user WHERE id = (
    SELECT owner_id FROM organizations WHERE id = (
      SELECT organization_id FROM repositories WHERE id = request.id
    )
  );

  -- Build Data JSON
  notification_json = jsonb_build_object(
    'request', request,
    'message', new
  );

  -- Create a notification for the organization user --
  if new.vendor then
    INSERT INTO public.notifications (user_id, text, type, data) VALUES (request.user_id, 'New Message Received', 'new_message', notification_json);
  else
    INSERT INTO public.notifications (user_id, text, type, data) VALUES (organization_user_id, 'New Message Received', 'new_message', notification_json);
  end if;

  return new;
END;
$$ LANGUAGE plpgsql security definer;

-- Create a trigger to run the notification_new_message function after a request comment (chat message) is created.
drop trigger if exists create_notification_on_new_message on public.request_comments;
create trigger create_notification_on_new_message
  after insert on public.request_comments
  for each row execute procedure public.notification_new_message();